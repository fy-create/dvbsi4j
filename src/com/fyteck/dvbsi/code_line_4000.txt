/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ReplaceUtil {
    public static String replace(String content, String regular, String dest) {
        return replace(content, regular, dest, 0);
    }

    public static String replace(String content, String regular, String dest, int flag) {
        Pattern pattern    = Pattern.compile(regular, flag/* Pattern.DOTALL */);
        Matcher matcher    = pattern.matcher(content);
        String  newComment = matcher.replaceAll(dest);
        return newComment;
    }

}
/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

public class NodeValue {
    private String name;
    private Object value;

    public NodeValue() {
        super();
    }

    NodeValue(String name, Object value) {
        super();
        this.name  = name;
        this.value = value;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @SuppressWarnings("unchecked")
    public <T extends Object> T getValue() {
        return (T) value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("NodeValue [name=");
        builder.append(name);
        builder.append(", value=");
        builder.append(value);
        builder.append("]");
        return builder.toString();
    }

}
/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

public class NumberUtil {
    public static String Object2Hex(Object object) {
        if (object.getClass() == Long.class) {
            return Long.toHexString((Long) object).toUpperCase();
        } else if (object.getClass() == Integer.class) {
            return Integer.toHexString((Integer) object).toUpperCase();
        } else if (object.getClass() == Short.class) {
            return Integer.toHexString((Short) object).toUpperCase();
        } else if (object.getClass() == Byte.class) {
            return Integer.toHexString((Byte) object).toUpperCase();
        } else if (object.getClass() == byte[].class) {
            byte[] bytes = (byte[]) object;
            if (bytes.length <= 4) {
                return StringUtil.getHexString(bytes);
            }
        }
        return "";
    }

    public static int getIntValue(Object object) {
        if (object == null) {
            return -1;
        }
        if (object.getClass() == Long.class) {
            return ((Long) object).intValue();
        } else if (object.getClass() == Integer.class) {
            return ((Integer) object).intValue();
        } else if (object.getClass() == Short.class) {
            return ((Short) object).intValue();
        } else if (object.getClass() == Byte.class) {
            return ((Byte) object).intValue();
        }
        return -1;
    }

    public static int unsignedByteToInt(byte b) {
        return (int) b & 0xFF;
    }
}
/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

import java.util.HashMap;
import java.util.Map;

public class PIDFilter {
    private Map<Integer, String> pids = new HashMap<Integer, String>();

    public void addPidFilter(int pid, String name) {
        if (pids.containsValue(name) && name.equals("PCR_PID")) {
            return;
        }
        if (pids.containsKey(pid)) {
            return;
        }
        pids.put(pid, name);
    }

    public boolean inPidFilter(int pid) {
        return pids.containsKey(pid);
    }

    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("Filter \r\n");
        for (Integer pid : pids.keySet()) {
            builder.append("pid:" + pid + " name:" + pids.get(pid) + "\r\n");
        }
        return builder.toString();
    }

}/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

import java.util.ArrayList;
import java.util.List;

public class TSUtil {

    public static <T extends Object> T getObjectByName(List<NodeValue> nodeList, String name) {
        if (nodeList == null || name == null) {
            return null;
        }
        T value = null;
        for (NodeValue node : nodeList) {
            if (node.getName().equals(name)) {
                value = node.getValue();
                break;
            }
        }

        return value;
    }

    public static int getObjectLenByName(List<NodeValue> objectList, String name) {
        if (objectList == null || name == null) {
            return 0;
        }
        if (objectList.getClass() != ArrayList.class) {
            return 0;
        }

        for (NodeValue node : objectList) {
            if (node.getName().equals(name)) {
                Object obj = node.getValue();
                if (obj.getClass() == ArrayList.class) {
                    List<NodeValue> _list = uncheckedCast(obj);
                    return _list.size();
                }
            }
        }
        return 0;
    }

    /**
     * 
     * @param <T>
     * @param nodeList
     * @param name
     * @param index
     * @return Object or List<NodeValue>
     */
    public static <T extends Object> T getObjectByNameIdx(List<NodeValue> nodeList, String name, int index) {
        if (nodeList.getClass() == ArrayList.class) {
            Object object = getObjectByName(nodeList, name);
            if (object.getClass() == ArrayList.class) {
                List<NodeValue> list = uncheckedCast(object);
                return list.get(index).getValue();
            }
        }
        return null;
    }

    public static void dumpNode(StringBuffer sb, List<NodeValue> values, int step, int formatLen) {
        if (values == null) {
            return;
        }

        for (NodeValue node : values) {
            if (node.getValue() == null) {
                continue;
            }
            if (node.getValue().getClass() == ArrayList.class) {
                String name = StringUtil.formatString(StringUtil.getString(step, ' ') + node.getName(), formatLen);
                sb.append(name + "\n");
                step += 2;
                List<NodeValue> list = node.getValue();
                dumpNode(sb, list, step, formatLen);
                step -= 2;
            } else if (node.getValue().getClass() == byte[].class) {
                String name      = StringUtil.formatString(StringUtil.getString(step, ' ') /***/
                        + node.getName() + "    ", formatLen);

                String hexPreFix = StringUtil.getString(name.length(), ' ');
                sb.append(name + StringUtil.getHexString((byte[]) node.getValue(), 16, hexPreFix) + "\n");
            } else {
                String name     = StringUtil.formatString(StringUtil.getString(step, ' ') /***/
                        + node.getName() + "    ", formatLen);

                String value    = StringUtil.formatString(node.getValue().toString(), 10);
                String hexValue = StringUtil.formatString(NumberUtil.Object2Hex(node.getValue()), 10);
                sb.append(name + value + " [0x" + hexValue + "]" + "\n");
            }
        }
    }

    public static <T> T uncheckedCast(Object obj) {
        @SuppressWarnings("unchecked")
        T t = (T) obj;
        return t;
    }

}
/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

import java.util.Arrays;
import java.util.List;

import org.apache.log4j.Logger;

public class SectionParser { //
    private static Logger log = Logger.getLogger(SectionParser.class);
    private byte[]        buffer;
    private int           bufferLen;
    private int           token;
    private int           bitUsed;
    private int           validBitPos;
    private int           needsBits;
    private int           allNeedsBits;

    public SectionParser() {
        super();
        token        = 0;
        bitUsed      = 0;
        validBitPos  = 0;
        needsBits    = 0;
        allNeedsBits = 0;
    }

    public void reset() { //
        token        = 0;
        bitUsed      = 0;
        validBitPos  = 0;
        needsBits    = 0;
        allNeedsBits = 0;
        buffer       = null;
        bufferLen    = 0;
    }

    public byte[] getBuffer() {
        return buffer;
    }

    public void setBuffer(byte[] buffer) {
        this.buffer = buffer;
    }

    public int getBufferLen() {
        return bufferLen;
    }

    public void setBufferLen(int bufferLen) {
        this.bufferLen = bufferLen;
    }

    public Object parseData(int bitused) throws Exception { //
        return parseData(bitused, true, false);
    }

    public int getToken() {
        return token;
    }

    public void setToken(int token) {
        this.token = token;
    }

    public Object parseData(String syntax) throws Exception { //
        List<String> list    = StringUtil.string2List(syntax, " ");
        // 1.varname
        // 2.bitused
        // 3.sequency not used
        int          bitused = Integer.parseInt(list.get(1));      // 2.bitused
        return parseData(bitused, true, false);
    }

    public Object parseData(int bitused, boolean parseBuffer, boolean skip) throws Exception { //
        Object obj = null;
        needsBits    = bitused;
        // System.out.print(token + " " + validBitPos + " " + needsBits);
        allNeedsBits = validBitPos + needsBits;
        if (parseBuffer) {
            if (bitused == 0) {
                return null;
            }
            if (allNeedsBits <= 8) {
                short _short = (short) (//
                (buffer[token] & ((0x1 << (8 - validBitPos)) - 1)) >> (8 - needsBits - validBitPos)//
                );
                _short &= 0x00FF;
                obj     = new Integer(_short);
            } else if (allNeedsBits <= 16) {
                int _int = (int) ((//
                (buffer[token] & 0xff) << 8) | //
                        (buffer[token + 1] & 0xFF));
                _int = (int) ((_int & ((0x1 << (16 - validBitPos)) - 1)) >> (16 - needsBits - validBitPos));
                obj  = new Integer(_int);
            } else if (allNeedsBits <= 32) {
                long _long = 0;
                if (allNeedsBits <= 24) {
                    _long = (long) (//
                    ((buffer[token] & 0xFF) << 24) | //
                            ((buffer[token + 1] & 0xFF) << 16) | //
                            ((buffer[token + 2] & 0xFF) << 8)); //
                } else {
                    _long = (long) (//
                    ((buffer[token] & 0xFF) << 24) | //
                            ((buffer[token + 1] & 0xFF) << 16) | //
                            ((buffer[token + 2] & 0xFF) << 8) | //
                            ((buffer[token + 3] & 0xFF) & 0xFF)//
                    );
                }
                _long = (long) ((_long & ((0x1L << (32 - validBitPos)) - 1)) >> (32 - needsBits - validBitPos));
                obj   = new Long((long) _long);
            } else {// copy buffer
                byte[] byteBuffer = new byte[bitused / 8];
                System.arraycopy(buffer, token, byteBuffer, 0, bitused / 8);
                obj = byteBuffer;
            }
        } else {
            if (!skip) {
                byte[] byteBuffer = new byte[bitused / 8];
                try {
                    System.arraycopy(buffer, token, byteBuffer, 0, bitused / 8);
                } catch (Exception e) {
                    throw e;
                }
                obj = byteBuffer;
            }
        }

        bitUsed     += needsBits;
        token        = bitUsed >> 3;
        validBitPos  = bitUsed - (token << 3);
        return obj;
    }

    public void printCurrent() { //
        log.info("Length=" + bufferLen + " Token=" + token + " bitused=" + bitUsed + "(" + bitUsed / 8 + ")"//
                + " validBitPos=" + validBitPos);
    }

    public boolean isEnd() {
        return (token >= this.bufferLen);
    }

    public void rewindBits(int bits) {
        bitUsed     -= bits;
        token        = bitUsed >> 3;
        validBitPos  = bitUsed - (token << 3);
    }

    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("SectionParser [buffer=");
        builder.append(Arrays.toString(buffer));
        builder.append(", bufferLen=");
        builder.append(bufferLen);
        builder.append(", token=");
        builder.append(token);
        builder.append(", bitUsed=");
        builder.append(bitUsed);
        builder.append(", validBitPos=");
        builder.append(validBitPos);
        builder.append(", needsBits=");
        builder.append(needsBits);
        builder.append(", allNeedsBits=");
        builder.append(allNeedsBits);
        builder.append("]");
        return builder.toString();
    }
}
/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

import org.antlr.runtime.BaseRecognizer;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.DFA;
import org.antlr.runtime.EarlyExitException;
import org.antlr.runtime.Lexer;
import org.antlr.runtime.MismatchedSetException;
import org.antlr.runtime.NoViableAltException;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.RecognizerSharedState;

@SuppressWarnings({ "all", "warnings", "unchecked" })
public class BitStreamLexer extends Lexer {
    public static final int EOF                = -1;
    public static final int T__46              = 46;
    public static final int T__47              = 47;
    public static final int T__48              = 48;
    public static final int T__49              = 49;
    public static final int T__50              = 50;
    public static final int T__51              = 51;
    public static final int T__52              = 52;
    public static final int T__53              = 53;
    public static final int T__54              = 54;
    public static final int T__55              = 55;
    public static final int T__56              = 56;
    public static final int T__57              = 57;
    public static final int T__58              = 58;
    public static final int T__59              = 59;
    public static final int T__60              = 60;
    public static final int T__61              = 61;
    public static final int T__62              = 62;
    public static final int T__63              = 63;
    public static final int T__64              = 64;
    public static final int T__65              = 65;
    public static final int T__66              = 66;
    public static final int T__67              = 67;
    public static final int T__68              = 68;
    public static final int BAG_END            = 4;
    public static final int BAG_START          = 5;
    public static final int BLK                = 6;
    public static final int DESCRIPTOR         = 7;
    public static final int EQ                 = 8;
    public static final int EQEQ               = 9;
    public static final int FOR                = 10;
    public static final int HexDigit           = 11;
    public static final int HexLiteral         = 12;
    public static final int ID                 = 13;
    public static final int INT                = 14;
    public static final int KEY_BREAK          = 15;
    public static final int KEY_CALL           = 16;
    public static final int KEY_DEF            = 17;
    public static final int KEY_ELSE           = 18;
    public static final int KEY_ELSEIF         = 19;
    public static final int KEY_FCT            = 20;
    public static final int KEY_FOR            = 21;
    public static final int KEY_FOR_BUFFER     = 22;
    public static final int KEY_FOR_DESCRIPTOR = 23;
    public static final int KEY_FOR_END        = 24;
    public static final int KEY_FOR_START      = 25;
    public static final int KEY_IDENT          = 26;
    public static final int KEY_IF             = 27;
    public static final int KEY_LB             = 28;
    public static final int KEY_LOGIC          = 29;
    public static final int KEY_NODE_END       = 30;
    public static final int KEY_NODE_START     = 31;
    public static final int KEY_POP            = 32;
    public static final int KEY_PUSH           = 33;
    public static final int KEY_RB             = 34;
    public static final int KEY_REWIND         = 35;
    public static final int KEY_WHILE          = 36;
    public static final int LBRACE             = 37;
    public static final int LT                 = 38;
    public static final int NEWLINE            = 39;
    public static final int NUMBER             = 40;
    public static final int PLUS               = 41;
    public static final int PROG               = 42;
    public static final int RBRACE             = 43;
    public static final int SYNTAX_NAME        = 44;
    public static final int WS                 = 45;

    // delegates
    // delegators
    public Lexer[] getDelegates() {
        return new Lexer[] {};
    }

    public BitStreamLexer() {
    }

    public BitStreamLexer(CharStream input) {
        this(input, new RecognizerSharedState());
    }

    public BitStreamLexer(CharStream input, RecognizerSharedState state) {
        super(input, state);
    }

    // $ANTLR start "T__46"
    public final void mT__46() throws RecognitionException {
        try {
            int _type    = T__46;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("!=");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__46"

    // $ANTLR start "T__47"
    public final void mT__47() throws RecognitionException {
        try {
            int _type    = T__47;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("&&");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__47"

    // $ANTLR start "T__48"
    public final void mT__48() throws RecognitionException {
        try {
            int _type    = T__48;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('(');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__48"

    // $ANTLR start "T__49"
    public final void mT__49() throws RecognitionException {
        try {
            int _type    = T__49;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("()");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__49"

    // $ANTLR start "T__50"
    public final void mT__50() throws RecognitionException {
        try {
            int _type    = T__50;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match(')');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__50"

    // $ANTLR start "T__51"
    public final void mT__51() throws RecognitionException {
        try {
            int _type    = T__51;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('*');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__51"

    // $ANTLR start "T__52"
    public final void mT__52() throws RecognitionException {
        try {
            int _type    = T__52;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('/');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__52"

    // $ANTLR start "T__53"
    public final void mT__53() throws RecognitionException {
        try {
            int _type    = T__53;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match(';');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__53"

    // $ANTLR start "T__54"
    public final void mT__54() throws RecognitionException {
        try {
            int _type    = T__54;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("<<<");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__54"

    // $ANTLR start "T__55"
    public final void mT__55() throws RecognitionException {
        try {
            int _type    = T__55;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("<=");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__55"

    // $ANTLR start "T__56"
    public final void mT__56() throws RecognitionException {
        try {
            int _type    = T__56;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('>');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__56"

    // $ANTLR start "T__57"
    public final void mT__57() throws RecognitionException {
        try {
            int _type    = T__57;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match(">=");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__57"

    // $ANTLR start "T__58"
    public final void mT__58() throws RecognitionException {
        try {
            int _type    = T__58;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match(">>>");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__58"

    // $ANTLR start "T__59"
    public final void mT__59() throws RecognitionException {
        try {
            int _type    = T__59;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("CALL ");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__59"

    // $ANTLR start "T__60"
    public final void mT__60() throws RecognitionException {
        try {
            int _type    = T__60;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("If");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__60"

    // $ANTLR start "T__61"
    public final void mT__61() throws RecognitionException {
        try {
            int _type    = T__61;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("NODE_END");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__61"

    // $ANTLR start "T__62"
    public final void mT__62() throws RecognitionException {
        try {
            int _type    = T__62;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("NODE_START");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__62"

    // $ANTLR start "T__63"
    public final void mT__63() throws RecognitionException {
        try {
            int _type    = T__63;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("break");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__63"

    // $ANTLR start "T__64"
    public final void mT__64() throws RecognitionException {
        try {
            int _type    = T__64;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("else");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__64"

    // $ANTLR start "T__65"
    public final void mT__65() throws RecognitionException {
        try {
            int _type    = T__65;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("if");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__65"

    // $ANTLR start "T__66"
    public final void mT__66() throws RecognitionException {
        try {
            int _type    = T__66;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("rewind");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__66"

    // $ANTLR start "T__67"
    public final void mT__67() throws RecognitionException {
        try {
            int _type    = T__67;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("while");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__67"

    // $ANTLR start "T__68"
    public final void mT__68() throws RecognitionException {
        try {
            int _type    = T__68;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("||");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "T__68"

    // $ANTLR start "DESCRIPTOR"
    public final void mDESCRIPTOR() throws RecognitionException {
        try {
            int _type    = DESCRIPTOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("descriptor()");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "DESCRIPTOR"

    // $ANTLR start "HexDigit"
    public final void mHexDigit() throws RecognitionException {
        try {

            // )

            {
                if (input.LA(1) == '-' || (input.LA(1) >= '0' && input.LA(1) <= '9') || (input.LA(1) >= 'A' && input.LA(1) <= 'F')
                        || (input.LA(1) >= 'a' && input.LA(1) <= 'f')) {
                    input.consume();
                } else {
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    recover(mse);
                    throw mse;
                }

            }

        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "HexDigit"

    // $ANTLR start "HexLiteral"
    public final void mHexLiteral() throws RecognitionException {
        try {
            int _type    = HexLiteral;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('0');

                if (input.LA(1) == 'X' || input.LA(1) == 'x') {
                    input.consume();
                } else {
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    recover(mse);
                    throw mse;
                }

                int cnt1 = 0;
                loop1: do {
                    int alt1  = 2;
                    int LA1_0 = input.LA(1);

                    if ((LA1_0 == '-' || (LA1_0 >= '0' && LA1_0 <= '9') || (LA1_0 >= 'A' && LA1_0 <= 'F') || (LA1_0 >= 'a' && LA1_0 <= 'f'))) {
                        alt1 = 1;
                    }

                    switch (alt1) {
                    case 1:

                    {
                        if (input.LA(1) == '-' || (input.LA(1) >= '0' && input.LA(1) <= '9') || (input.LA(1) >= 'A' && input.LA(1) <= 'F')
                                || (input.LA(1) >= 'a' && input.LA(1) <= 'f')) {
                            input.consume();
                        } else {
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            recover(mse);
                            throw mse;
                        }

                    }
                        break;

                    default:
                        if (cnt1 >= 1)
                            break loop1;
                        EarlyExitException eee = new EarlyExitException(1, input);
                        throw eee;
                    }
                    cnt1++;
                } while (true);

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "HexLiteral"

    // $ANTLR start "FOR"
    public final void mFOR() throws RecognitionException {
        try {
            int _type    = FOR;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            int alt2     = 2;
            int LA2_0    = input.LA(1);

            if ((LA2_0 == 'f')) {
                alt2 = 1;
            } else if ((LA2_0 == 'F')) {
                alt2 = 2;
            } else {
                NoViableAltException nvae = new NoViableAltException("", 2, 0, input);

                throw nvae;

            }
            switch (alt2) {
            case 1:

            {
                match("for");

            }
                break;
            case 2:

            {
                match("FOR");

            }
                break;

            }
            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "FOR"

    // $ANTLR start "ID"
    public final void mID() throws RecognitionException {
        try {
            int _type    = ID;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            int var_id;

            // .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '-' )* )

            // .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '-' )*
            {
                var_id = input.LA(1);

                if ((input.LA(1) >= 'A' && input.LA(1) <= 'Z') || input.LA(1) == '_' || (input.LA(1) >= 'a' && input.LA(1) <= 'z')) {
                    input.consume();
                } else {
                    MismatchedSetException mse = new MismatchedSetException(null, input);
                    recover(mse);
                    throw mse;
                }

                // | '-' )*
                loop3: do {
                    int alt3  = 2;
                    int LA3_0 = input.LA(1);

                    if ((LA3_0 == '-' || (LA3_0 >= '0' && LA3_0 <= '9') || (LA3_0 >= 'A' && LA3_0 <= 'Z') || LA3_0 == '_'
                            || (LA3_0 >= 'a' && LA3_0 <= 'z'))) {
                        alt3 = 1;
                    }

                    switch (alt3) {
                    case 1:

                    {
                        if (input.LA(1) == '-' || (input.LA(1) >= '0' && input.LA(1) <= '9') || (input.LA(1) >= 'A' && input.LA(1) <= 'Z')
                                || input.LA(1) == '_' || (input.LA(1) >= 'a' && input.LA(1) <= 'z')) {
                            input.consume();
                        } else {
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            recover(mse);
                            throw mse;
                        }

                    }
                        break;

                    default:
                        break loop3;
                    }
                } while (true);

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "ID"

    // $ANTLR start "SYNTAX_NAME"
    public final void mSYNTAX_NAME() throws RecognitionException {
        try {
            int _type    = SYNTAX_NAME;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {

                loop4: do {
                    int alt4  = 3;
                    int LA4_0 = input.LA(1);

                    if (((LA4_0 >= 'A' && LA4_0 <= 'Z') || LA4_0 == '_' || (LA4_0 >= 'a' && LA4_0 <= 'z'))) {
                        alt4 = 1;
                    } else if ((LA4_0 == '.')) {
                        alt4 = 2;
                    }

                    switch (alt4) {
                    case 1:

                    {
                        mID();

                    }
                        break;
                    case 2:

                    {
                        match('.');

                    }
                        break;

                    default:
                        break loop4;
                    }
                } while (true);

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "SYNTAX_NAME"

    // $ANTLR start "NUMBER"
    public final void mNUMBER() throws RecognitionException {
        try {
            int _type    = NUMBER;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("(0x)");

                mINT();

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "NUMBER"

    // $ANTLR start "INT"
    public final void mINT() throws RecognitionException {
        try {
            int _type    = INT;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            int var_int;

            {

                int cnt5 = 0;
                loop5: do {
                    int alt5  = 2;
                    int LA5_0 = input.LA(1);

                    if ((LA5_0 == '-' || (LA5_0 >= '0' && LA5_0 <= '9'))) {
                        alt5 = 1;
                    }

                    switch (alt5) {
                    case 1:

                    {
                        var_int = input.LA(1);

                        if (input.LA(1) == '-' || (input.LA(1) >= '0' && input.LA(1) <= '9')) {
                            input.consume();
                        } else {
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            recover(mse);
                            throw mse;
                        }

                    }
                        break;

                    default:
                        if (cnt5 >= 1)
                            break loop5;
                        EarlyExitException eee = new EarlyExitException(5, input);
                        throw eee;
                    }
                    cnt5++;
                } while (true);

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "INT"

    // $ANTLR start "EQ"
    public final void mEQ() throws RecognitionException {
        try {
            int _type    = EQ;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('=');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "EQ"

    // $ANTLR start "EQEQ"
    public final void mEQEQ() throws RecognitionException {
        try {
            int _type    = EQEQ;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match("==");

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "EQEQ"

    // $ANTLR start "LT"
    public final void mLT() throws RecognitionException {
        try {
            int _type    = LT;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('<');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "LT"

    // $ANTLR start "PLUS"
    public final void mPLUS() throws RecognitionException {
        try {
            int _type    = PLUS;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('+');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "PLUS"

    // $ANTLR start "LBRACE"
    public final void mLBRACE() throws RecognitionException {
        try {
            int _type    = LBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('{');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "LBRACE"

    // $ANTLR start "RBRACE"
    public final void mRBRACE() throws RecognitionException {
        try {
            int _type    = RBRACE;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {
                match('}');

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "RBRACE"

    // $ANTLR start "NEWLINE"
    public final void mNEWLINE() throws RecognitionException {
        try {
            int _type    = NEWLINE;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {

                int alt6  = 2;
                int LA6_0 = input.LA(1);

                if ((LA6_0 == '\r')) {
                    alt6 = 1;
                }
                switch (alt6) {
                case 1:

                {
                    match('\r');

                }
                    break;

                }

                match('\n');

                _channel = HIDDEN;

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "NEWLINE"

    // $ANTLR start "WS"
    public final void mWS() throws RecognitionException {
        try {
            int _type    = WS;
            int _channel = DEFAULT_TOKEN_CHANNEL;

            {

                int cnt7 = 0;
                loop7: do {
                    int alt7  = 2;
                    int LA7_0 = input.LA(1);

                    if (((LA7_0 >= '\t' && LA7_0 <= '\n') || LA7_0 == '\r' || LA7_0 == ' ')) {
                        alt7 = 1;
                    }

                    switch (alt7) {
                    case 1:

                    {
                        if ((input.LA(1) >= '\t' && input.LA(1) <= '\n') || input.LA(1) == '\r' || input.LA(1) == ' ') {
                            input.consume();
                        } else {
                            MismatchedSetException mse = new MismatchedSetException(null, input);
                            recover(mse);
                            throw mse;
                        }

                    }
                        break;

                    default:
                        if (cnt7 >= 1)
                            break loop7;
                        EarlyExitException eee = new EarlyExitException(7, input);
                        throw eee;
                    }
                    cnt7++;
                } while (true);

                _channel = HIDDEN;

            }

            state.type    = _type;
            state.channel = _channel;
        } finally {
            // do for sure before leaving
        }
    }
    // $ANTLR end "WS"

    public void mTokens() throws RecognitionException {

        // T__52 | T__53 | T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61
        // | T__62 | T__63 | T__64 | T__65
        // | T__66 | T__67 |
        // T__68 | DESCRIPTOR | HexLiteral | FOR | ID | SYNTAX_NAME | NUMBER | INT | EQ
        // | EQEQ | LT | PLUS | LBRACE |
        // RBRACE | NEWLINE | WS
        // )
        int alt8 = 38;
        alt8 = dfa8.predict(input);
        switch (alt8) {
        case 1:

        {
            mT__46();

        }
            break;
        case 2:

        {
            mT__47();

        }
            break;
        case 3:

        {
            mT__48();

        }
            break;
        case 4:

        {
            mT__49();

        }
            break;
        case 5:

        {
            mT__50();

        }
            break;
        case 6:

        {
            mT__51();

        }
            break;
        case 7:

        {
            mT__52();

        }
            break;
        case 8:

        {
            mT__53();

        }
            break;
        case 9:

        {
            mT__54();

        }
            break;
        case 10:

        {
            mT__55();

        }
            break;
        case 11:

        {
            mT__56();

        }
            break;
        case 12:

        {
            mT__57();

        }
            break;
        case 13:

        {
            mT__58();

        }
            break;
        case 14:

        {
            mT__59();

        }
            break;
        case 15:

        {
            mT__60();

        }
            break;
        case 16:

        {
            mT__61();

        }
            break;
        case 17:

        {
            mT__62();

        }
            break;
        case 18:

        {
            mT__63();

        }
            break;
        case 19:

        {
            mT__64();

        }
            break;
        case 20:

        {
            mT__65();

        }
            break;
        case 21:

        {
            mT__66();

        }
            break;
        case 22:

        {
            mT__67();

        }
            break;
        case 23:

        {
            mT__68();

        }
            break;
        case 24:

        {
            mDESCRIPTOR();

        }
            break;
        case 25:

        {
            mHexLiteral();

        }
            break;
        case 26:

        {
            mFOR();

        }
            break;
        case 27:

        {
            mID();

        }
            break;
        case 28:

        {
            mSYNTAX_NAME();

        }
            break;
        case 29:

        {
            mNUMBER();

        }
            break;
        case 30:

        {
            mINT();

        }
            break;
        case 31:

        {
            mEQ();

        }
            break;
        case 32:

        {
            mEQEQ();

        }
            break;
        case 33:

        {
            mLT();

        }
            break;
        case 34:

        {
            mPLUS();

        }
            break;
        case 35:

        {
            mLBRACE();

        }
            break;
        case 36:

        {
            mRBRACE();

        }
            break;
        case 37:

        {
            mNEWLINE();

        }
            break;
        case 38:

        {
            mWS();

        }
            break;

        }

    }

    protected DFA8         dfa8             = new DFA8(this);
    static final String    DFA8_eotS        = "\1\30\2\uffff\1\43\4\uffff\1\46\1\51\10\54\1\uffff\1\54\1\31\3\54"
            + "\2\uffff\1\72\3\uffff\1\40\1\73\12\uffff\2\54\1\uffff\1\54\1\75" + "\3\54\1\101\3\54\1\uffff\2\54\3\uffff\1\54\1\uffff\3\54\1\uffff"
            + "\3\54\2\116\3\54\1\122\3\54\2\uffff\1\54\1\130\1\uffff\1\54\1\132" + "\3\54\1\uffff\1\136\1\uffff\3\54\1\uffff\1\54\1\143\2\54\1\uffff"
            + "\2\54\1\150\1\54\2\uffff";
    static final String    DFA8_eofS        = "\152\uffff";
    static final String    DFA8_minS        = "\1\11\2\uffff\1\51\4\uffff\1\74\1\75\10\55\1\uffff\1\55\1\130\3"
            + "\55\2\uffff\1\75\3\uffff\1\12\1\11\12\uffff\2\55\1\uffff\11\55\1"
            + "\uffff\2\55\3\uffff\1\55\1\uffff\3\55\1\uffff\5\55\1\40\6\55\2\uffff"
            + "\2\55\1\uffff\5\55\1\uffff\1\55\1\uffff\3\55\1\uffff\4\55\1\uffff" + "\3\55\1\50\2\uffff";
    static final String    DFA8_maxS        = "\1\175\2\uffff\1\60\4\uffff\1\75\1\76\10\172\1\uffff\1\172\1\170"
            + "\3\172\2\uffff\1\75\3\uffff\1\12\1\40\12\uffff\2\172\1\uffff\11" + "\172\1\uffff\2\172\3\uffff\1\172\1\uffff\3\172\1\uffff\14\172\2"
            + "\uffff\2\172\1\uffff\5\172\1\uffff\1\172\1\uffff\3\172\1\uffff\4" + "\172\1\uffff\4\172\2\uffff";
    static final String    DFA8_acceptS     = "\1\uffff\1\1\1\2\1\uffff\1\5\1\6\1\7\1\10\12\uffff\1\27\5\uffff"
            + "\1\34\1\36\1\uffff\1\42\1\43\1\44\2\uffff\1\46\1\4\1\35\1\3\1\11" + "\1\12\1\41\1\14\1\15\1\13\2\uffff\1\33\11\uffff\1\31\2\uffff\1\40"
            + "\1\37\1\45\1\uffff\1\17\3\uffff\1\24\14\uffff\1\32\1\16\2\uffff" + "\1\23\5\uffff\1\22\1\uffff\1\26\3\uffff\1\25\4\uffff\1\20\4\uffff"
            + "\1\21\1\30";
    static final String    DFA8_specialS    = "\152\uffff}>";
    static final String[]  DFA8_transitionS = {
            "\1\40\1\37\2\uffff\1\36\22\uffff\1\40\1\1\4\uffff\1\2\1\uffff" + "\1\3\1\4\1\5\1\33\1\uffff\1\31\1\uffff\1\6\1\24\11\31\1\uffff"
                    + "\1\7\1\10\1\32\1\11\2\uffff\2\27\1\12\2\27\1\26\2\27\1\13\4" + "\27\1\14\14\27\4\uffff\1\27\1\uffff\1\27\1\15\1\27\1\23\1\16"
                    + "\1\25\2\27\1\17\10\27\1\20\4\27\1\21\3\27\1\34\1\22\1\35",
            "", "", "\1\41\6\uffff\1\42", "", "", "", "", "\1\44\1\45", "\1\47\1\50",
            "\1\55\1\30\1\uffff\12\55\7\uffff\1\52\31\53\4\uffff\1\53\1" + "\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\5\53\1\56\24\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\16\53\1\57\13\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\21\53\1\60\10\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\13\53\1\61\16\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\5\53\1\62\24\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\4\53\1\63\25\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\7\53\1\64\22\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\4\53\1\65\25\53", "\1\66\37\uffff\1\66",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\16\53\1\67\13\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\16\53\1\70\13\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53", "", "", "\1\71", "", "", "", "\1\37",
            "\2\40\2\uffff\1\40\22\uffff\1\40", "", "", "", "", "", "", "", "", "", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\13\53\1\74\16\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\3\53\1\76\26\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\4\53\1\77\25\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\22\53\1\100\7\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\26\53\1\102\3\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\10\53\1\103\21\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\22\53\1\104\7\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\21\53\1\105\10\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\21\53\1\106\10\53\4\uffff" + "\1\53\1\uffff\32\53", "", "", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\13\53\1\107\16\53\4\uffff" + "\1\53\1\uffff\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\4\53\1\110\25\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\1\111\31\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\4\53\1\112\25\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\10\53\1\113\21\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\13\53\1\114\16\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\2\53\1\115\27\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\117\14\uffff\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff" + "\1\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\120\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\12\53\1\121\17\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\15\53\1\123\14\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\4\53\1\124\25\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\21\53\1\125\10\53", "", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\4\53\1\126\15\53\1\127\7\53" + "\4\uffff\1\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\3\53\1\131\26\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\10\53\1\133\21\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\15\53\1\134\14\53\4\uffff" + "\1\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\23\53\1\135\6\53\4\uffff\1" + "\53\1\uffff\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\17\53\1\137\12\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\3\53\1\140\26\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\1\141\31\53\4\uffff\1\53\1" + "\uffff\32\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\23\53\1\142\6\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\21\53\1\144\10\53\4\uffff" + "\1\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\16\53\1\145\13\53", "",
            "\1\55\1\30\1\uffff\12\55\7\uffff\23\53\1\146\6\53\4\uffff\1" + "\53\1\uffff\32\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\21\53\1\147\10\53",
            "\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff\1\53\1\uffff" + "\32\53",
            "\1\151\4\uffff\1\55\1\30\1\uffff\12\55\7\uffff\32\53\4\uffff" + "\1\53\1\uffff\32\53", "", "" };

    static final short[]   DFA8_eot         = DFA.unpackEncodedString(DFA8_eotS);
    static final short[]   DFA8_eof         = DFA.unpackEncodedString(DFA8_eofS);
    static final char[]    DFA8_min         = DFA.unpackEncodedStringToUnsignedChars(DFA8_minS);
    static final char[]    DFA8_max         = DFA.unpackEncodedStringToUnsignedChars(DFA8_maxS);
    static final short[]   DFA8_accept      = DFA.unpackEncodedString(DFA8_acceptS);
    static final short[]   DFA8_special     = DFA.unpackEncodedString(DFA8_specialS);
    static final short[][] DFA8_transition;

    static {
        int numStates = DFA8_transitionS.length;
        DFA8_transition = new short[numStates][];
        for (int i = 0; i < numStates; i++) {
            DFA8_transition[i] = DFA.unpackEncodedString(DFA8_transitionS[i]);
        }
    }

    class DFA8 extends DFA {

        public DFA8(BaseRecognizer recognizer) {
            this.recognizer     = recognizer;
            this.decisionNumber = 8;
            this.eot            = DFA8_eot;
            this.eof            = DFA8_eof;
            this.min            = DFA8_min;
            this.max            = DFA8_max;
            this.accept         = DFA8_accept;
            this.special        = DFA8_special;
            this.transition     = DFA8_transition;
        }

        public String getDescription() {
            return "1:1: Tokens : ( T__46 | T__47 | T__48 | T__49 | T__50 | T__51 | T__52 | T__53 | T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | DESCRIPTOR | HexLiteral | FOR | ID | SYNTAX_NAME | NUMBER | INT | EQ | EQEQ | LT | PLUS | LBRACE | RBRACE | NEWLINE | WS );";
        }
    }

}/*******************************************************************************
 * Copyright (c) 2021 FuYou Technology
 *
 *
 *   The content of this file includes portions of the FY Technology
 *   released in source code form as part of the SDK installer package.
 *   
 *   Commercial License Usage
 *   
 *   Licensees holding valid commercial licenses to the FY Technology
 *   may use this file in accordance with the end user license agreement provided 
 *   with the software or, alternatively, in accordance with the terms contained in a
 *   written agreement between you and FY Inc.
 *   
 *   
 *   
 *   GNU General Public License Usage
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *  
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *  
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
 *******************************************************************************/
package com.fyteck.dvbsi;

//import org.apache.log4j.Logger;
import java.util.LinkedList;
import java.util.List;

import org.antlr.runtime.BitSet;
import org.antlr.runtime.EarlyExitException;
import org.antlr.runtime.MismatchedSetException;
import org.antlr.runtime.NoViableAltException;
import org.antlr.runtime.Parser;
import org.antlr.runtime.ParserRuleReturnScope;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.RecognizerSharedState;
import org.antlr.runtime.Token;
import org.antlr.runtime.TokenStream;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeAdaptor;
import org.antlr.runtime.tree.RewriteRuleSubtreeStream;
import org.antlr.runtime.tree.RewriteRuleTokenStream;
import org.antlr.runtime.tree.TreeAdaptor;

@SuppressWarnings({ "all", "warnings", "unchecked" })
public class BitStreamParser extends Parser {
    public static final String[] tokenNames         = new String[] { "<invalid>", "<EOR>", "<DOWN>", "<UP>", "BAG_END", "BAG_START", "BLK",
            "DESCRIPTOR", "EQ", "EQEQ", "FOR", "HexDigit", "HexLiteral", "ID", "INT", "KEY_BREAK", "KEY_CALL", "KEY_DEF", "KEY_ELSE", "KEY_ELSEIF",
            "KEY_FCT", "KEY_FOR", "KEY_FOR_BUFFER", "KEY_FOR_DESCRIPTOR", "KEY_FOR_END", "KEY_FOR_START", "KEY_IDENT", "KEY_IF", "KEY_LB",
            "KEY_LOGIC", "KEY_NODE_END", "KEY_NODE_START", "KEY_POP", "KEY_PUSH", "KEY_RB", "KEY_REWIND", "KEY_WHILE", "LBRACE", "LT", "NEWLINE",
            "NUMBER", "PLUS", "PROG", "RBRACE", "SYNTAX_NAME", "WS", "'!='", "'&&'", "'('", "'()'", "')'", "'*'", "'/'", "';'", "'<<<'", "'<='",
            "'>'", "'>='", "'>>>'", "'CALL '", "'If'", "'NODE_END'", "'NODE_START'", "'break'", "'else'", "'if'", "'rewind'", "'while'", "'||'" };

    public static final int      EOF                = -1;
    public static final int      T__46              = 46;
    public static final int      T__47              = 47;
    public static final int      T__48              = 48;
    public static final int      T__49              = 49;
    public static final int      T__50              = 50;
    public static final int      T__51              = 51;
    public static final int      T__52              = 52;
    public static final int      T__53              = 53;
    public static final int      T__54              = 54;
    public static final int      T__55              = 55;
    public static final int      T__56              = 56;
    public static final int      T__57              = 57;
    public static final int      T__58              = 58;
    public static final int      T__59              = 59;
    public static final int      T__60              = 60;
    public static final int      T__61              = 61;
    public static final int      T__62              = 62;
    public static final int      T__63              = 63;
    public static final int      T__64              = 64;
    public static final int      T__65              = 65;
    public static final int      T__66              = 66;
    public static final int      T__67              = 67;
    public static final int      T__68              = 68;
    public static final int      BAG_END            = 4;
    public static final int      BAG_START          = 5;
    public static final int      BLK                = 6;
    public static final int      DESCRIPTOR         = 7;
    public static final int      EQ                 = 8;
    public static final int      EQEQ               = 9;
    public static final int      FOR                = 10;
    public static final int      HexDigit           = 11;
    public static final int      HexLiteral         = 12;
    public static final int      ID                 = 13;
    public static final int      INT                = 14;
    public static final int      KEY_BREAK          = 15;
    public static final int      KEY_CALL           = 16;
    public static final int      KEY_DEF            = 17;
    public static final int      KEY_ELSE           = 18;
    public static final int      KEY_ELSEIF         = 19;
    public static final int      KEY_FCT            = 20;
    public static final int      KEY_FOR            = 21;
    public static final int      KEY_FOR_BUFFER     = 22;
    public static final int      KEY_FOR_DESCRIPTOR = 23;
    public static final int      KEY_FOR_END        = 24;
    public static final int      KEY_FOR_START      = 25;
    public static final int      KEY_IDENT          = 26;
    public static final int      KEY_IF             = 27;
    public static final int      KEY_LB             = 28;
    public static final int      KEY_LOGIC          = 29;
    public static final int      KEY_NODE_END       = 30;
    public static final int      KEY_NODE_START     = 31;
    public static final int      KEY_POP            = 32;
    public static final int      KEY_PUSH           = 33;
    public static final int      KEY_RB             = 34;
    public static final int      KEY_REWIND         = 35;
    public static final int      KEY_WHILE          = 36;
    public static final int      LBRACE             = 37;
    public static final int      LT                 = 38;
    public static final int      NEWLINE            = 39;
    public static final int      NUMBER             = 40;
    public static final int      PLUS               = 41;
    public static final int      PROG               = 42;
    public static final int      RBRACE             = 43;
    public static final int      SYNTAX_NAME        = 44;
    public static final int      WS                 = 45;

    // delegates
    public Parser[] getDelegates() {
        return new Parser[] {};
    }

    // delegators

    public BitStreamParser(TokenStream input) {
        this(input, new RecognizerSharedState());
    }

    public BitStreamParser(TokenStream input, RecognizerSharedState state) {
        super(input, state);
    }

    protected TreeAdaptor adaptor = new CommonTreeAdaptor();

    public void setTreeAdaptor(TreeAdaptor adaptor) {
        this.adaptor = adaptor;
    }

    public TreeAdaptor getTreeAdaptor() {
        return adaptor;
    }

    public String[] getTokenNames() {
        return BitStreamParser.tokenNames;
    }


    private List<String> errors = new LinkedList<String>();

    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {
        String hdr = getErrorHeader(e);
        String msg = getErrorMessage(e, tokenNames);
        errors.add(hdr + " " + msg);
    }

    public List<String> getErrors() {
        return errors;
    }

    public static class identiy_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "identiy"

    // KEY_IDENT ID HexLiteral NEWLINE ) ;
    public final BitStreamParser.identiy_return identiy() throws RecognitionException {
        BitStreamParser.identiy_return retval = new BitStreamParser.identiy_return();
        retval.start = input.LT(1);

        CommonTree             root_0             = null;

        Token                  var_key            = null;
        Token                  var_value          = null;
        Token                  char_literal1      = null;

        CommonTree             var_key_tree       = null;
        CommonTree             var_value_tree     = null;
        CommonTree             char_literal1_tree = null;
        RewriteRuleTokenStream stream_HexLiteral  = new RewriteRuleTokenStream(adaptor, "token HexLiteral");
        RewriteRuleTokenStream stream_EQ          = new RewriteRuleTokenStream(adaptor, "token EQ");
        RewriteRuleTokenStream stream_ID          = new RewriteRuleTokenStream(adaptor, "token ID");

        try {

            // KEY_IDENT ID HexLiteral NEWLINE ) )

            {

                {
                    var_key = (Token) match(input, ID, FOLLOW_ID_in_identiy214);
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_ID.add(var_key);

                    char_literal1 = (Token) match(input, EQ, FOLLOW_EQ_in_identiy216);
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_EQ.add(char_literal1);

                    var_value = (Token) match(input, HexLiteral, FOLLOW_HexLiteral_in_identiy220);
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_HexLiteral.add(var_value);

                }

                // AST REWRITE
                // elements: ID, HexLiteral
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 64:5: -> ^( KEY_IDENT ID HexLiteral NEWLINE )
                    {

                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_IDENT, "KEY_IDENT"), root_1);

                            adaptor.addChild(root_1, stream_ID.nextNode());

                            adaptor.addChild(root_1, stream_HexLiteral.nextNode());

                            adaptor.addChild(root_1, (CommonTree) adaptor.create(NEWLINE, "NEWLINE"));

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "identiy"

    public static class program_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "program"

    // )? ID block ) ;
    public final BitStreamParser.program_return program() throws RecognitionException {
        BitStreamParser.program_return retval = new BitStreamParser.program_return();
        retval.start = input.LT(1);

        CommonTree                     root_0               = null;

        Token                          ID3                  = null;
        Token                          string_literal4      = null;
        BitStreamParser.identiy_return identiy2             = null;

        BitStreamParser.block_return   block5               = null;

        CommonTree                     ID3_tree             = null;
        CommonTree                     string_literal4_tree = null;
        RewriteRuleTokenStream         stream_49            = new RewriteRuleTokenStream(adaptor, "token 49");
        RewriteRuleTokenStream         stream_ID            = new RewriteRuleTokenStream(adaptor, "token ID");
        RewriteRuleSubtreeStream       stream_identiy       = new RewriteRuleSubtreeStream(adaptor, "rule identiy");
        RewriteRuleSubtreeStream       stream_block         = new RewriteRuleSubtreeStream(adaptor, "rule block");
        try {

            // )? ID block ) )

            {

                int alt1  = 2;
                int LA1_0 = input.LA(1);

                if ((LA1_0 == ID)) {
                    int LA1_1 = input.LA(2);

                    if ((LA1_1 == EQ)) {
                        alt1 = 1;
                    }
                }
                switch (alt1) {
                case 1:

                {
                    pushFollow(FOLLOW_identiy_in_program259);
                    identiy2 = identiy();

                    state._fsp--;
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_identiy.add(identiy2.getTree());

                }
                    break;

                }

                ID3 = (Token) match(input, ID, FOLLOW_ID_in_program263);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_ID.add(ID3);

                string_literal4 = (Token) match(input, 49, FOLLOW_49_in_program265);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_49.add(string_literal4);

                pushFollow(FOLLOW_block_in_program267);
                block5 = block();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_block.add(block5.getTree());

                // AST REWRITE
                // elements: identiy, block, ID
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 71:5: -> ^( PROG ( identiy )? ID block )
                    {

                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(PROG, "PROG"), root_1);

                            if (stream_identiy.hasNext()) {
                                adaptor.addChild(root_1, stream_identiy.nextTree());

                            }
                            stream_identiy.reset();

                            adaptor.addChild(root_1, stream_ID.nextNode());

                            adaptor.addChild(root_1, stream_block.nextTree());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "program"

    public static class body_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "body"

    public final BitStreamParser.body_return body() throws RecognitionException {
        BitStreamParser.body_return retval = new BitStreamParser.body_return();
        retval.start = input.LT(1);

        CommonTree                       root_0     = null;

        BitStreamParser.statement_return statement6 = null;

        try {

            {
                root_0 = (CommonTree) adaptor.nil();

                int cnt2 = 0;
                loop2: do {
                    int alt2  = 2;
                    int LA2_0 = input.LA(1);

                    if ((LA2_0 == FOR || LA2_0 == ID || LA2_0 == 54 || (LA2_0 >= 58 && LA2_0 <= 63) || (LA2_0 >= 65 && LA2_0 <= 67))) {
                        alt2 = 1;
                    }

                    switch (alt2) {
                    case 1:

                    {
                        pushFollow(FOLLOW_statement_in_body306);
                        statement6 = statement();

                        state._fsp--;
                        if (state.failed)
                            return retval;
                        if (state.backtracking == 0)
                            adaptor.addChild(root_0, statement6.getTree());

                    }
                        break;

                    default:
                        if (cnt2 >= 1)
                            break loop2;
                        if (state.backtracking > 0) {
                            state.failed = true;
                            return retval;
                        }
                        EarlyExitException eee = new EarlyExitException(2, input);
                        throw eee;
                    }
                    cnt2++;
                } while (true);

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "body"

    public static class define_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "define"

    // )? -> ^( KEY_DEF ID INT ID ) ;
    public final BitStreamParser.define_return define() throws RecognitionException {
        BitStreamParser.define_return retval = new BitStreamParser.define_return();
        retval.start = input.LT(1);

        CommonTree                     root_0         = null;

        Token                          var_key        = null;
        Token                          var_len        = null;
        Token                          var_type       = null;
        BitStreamParser.bagName_return bagName7       = null;

        CommonTree                     var_key_tree   = null;
        CommonTree                     var_len_tree   = null;
        CommonTree                     var_type_tree  = null;
        RewriteRuleTokenStream         stream_INT     = new RewriteRuleTokenStream(adaptor, "token INT");
        RewriteRuleTokenStream         stream_ID      = new RewriteRuleTokenStream(adaptor, "token ID");
        RewriteRuleSubtreeStream       stream_bagName = new RewriteRuleSubtreeStream(adaptor, "rule bagName");
        try {

            // )? -> ^( KEY_DEF ID INT ID ) )

            // )?
            {
                var_key = (Token) match(input, ID, FOLLOW_ID_in_define325);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_ID.add(var_key);

                var_len = (Token) match(input, INT, FOLLOW_INT_in_define329);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_INT.add(var_len);

                var_type = (Token) match(input, ID, FOLLOW_ID_in_define333);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_ID.add(var_type);

                int alt3  = 2;
                int LA3_0 = input.LA(1);

                if ((LA3_0 == 52)) {
                    alt3 = 1;
                }
                switch (alt3) {
                case 1:

                {
                    pushFollow(FOLLOW_bagName_in_define335);
                    bagName7 = bagName();

                    state._fsp--;
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_bagName.add(bagName7.getTree());

                }
                    break;

                }

                // AST REWRITE
                // elements: ID, INT, ID
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 83:5: -> ^( KEY_DEF ID INT ID )
                    {

                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_DEF, "KEY_DEF"), root_1);

                            adaptor.addChild(root_1, stream_ID.nextNode());

                            adaptor.addChild(root_1, stream_INT.nextNode());

                            adaptor.addChild(root_1, stream_ID.nextNode());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "define"

    public static class statement_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "statement"

    // funcStat | condStat | define | bagStart | bagEnd | whileStat | breakStmt |
    // rewindStmt | nodeStart | nodeEnd |
    // callSyntax );
    public final BitStreamParser.statement_return statement() throws RecognitionException {
        BitStreamParser.statement_return retval = new BitStreamParser.statement_return();
        retval.start = input.LT(1);

        CommonTree                             root_0       = null;

        BitStreamParser.forDescriptStat_return var_stmt     = null;

        BitStreamParser.forStat_return         forStat8     = null;

        BitStreamParser.funcStat_return        funcStat9    = null;

        BitStreamParser.condStat_return        condStat10   = null;

        BitStreamParser.define_return          define11     = null;

        BitStreamParser.bagStart_return        bagStart12   = null;

        BitStreamParser.bagEnd_return          bagEnd13     = null;

        BitStreamParser.whileStat_return       whileStat14  = null;

        BitStreamParser.breakStmt_return       breakStmt15  = null;

        BitStreamParser.rewindStmt_return      rewindStmt16 = null;

        BitStreamParser.nodeStart_return       nodeStart17  = null;

        BitStreamParser.nodeEnd_return         nodeEnd18    = null;

        BitStreamParser.callSyntax_return      callSyntax19 = null;

        try {

            // condStat | define | bagStart | bagEnd | whileStat | breakStmt | rewindStmt |
            // nodeStart | nodeEnd |
            // callSyntax )
            int alt4 = 13;
            switch (input.LA(1)) {
            case FOR: {
                int LA4_1 = input.LA(2);

                if ((LA4_1 == 48)) {
                    int LA4_12 = input.LA(3);

                    if ((LA4_12 == ID)) {
                        int LA4_15 = input.LA(4);

                        if ((LA4_15 == EQ)) {
                            int LA4_16 = input.LA(5);

                            if ((LA4_16 == INT)) {
                                int LA4_17 = input.LA(6);

                                if ((LA4_17 == 53)) {
                                    int LA4_18 = input.LA(7);

                                    if ((LA4_18 == ID)) {
                                        int LA4_19 = input.LA(8);

                                        if ((LA4_19 == LT)) {
                                            int LA4_20 = input.LA(9);

                                            if ((LA4_20 == ID)) {
                                                int LA4_21 = input.LA(10);

                                                if ((LA4_21 == 53)) {
                                                    int LA4_22 = input.LA(11);

                                                    if ((LA4_22 == ID)) {
                                                        int LA4_23 = input.LA(12);

                                                        if ((LA4_23 == PLUS)) {
                                                            int LA4_24 = input.LA(13);

                                                            if ((LA4_24 == PLUS)) {
                                                                int LA4_25 = input.LA(14);

                                                                if ((LA4_25 == 50)) {
                                                                    int LA4_26 = input.LA(15);

                                                                    if ((LA4_26 == LBRACE)) {
                                                                        int LA4_27 = input.LA(16);

                                                                        if ((LA4_27 == DESCRIPTOR)) {
                                                                            alt4 = 1;
                                                                        } else if ((LA4_27 == FOR || LA4_27 == ID || LA4_27 == 54
                                                                                || (LA4_27 >= 58 && LA4_27 <= 63)
                                                                                || (LA4_27 >= 65 && LA4_27 <= 67))) {
                                                                            alt4 = 2;
                                                                        } else {
                                                                            if (state.backtracking > 0) {
                                                                                state.failed = true;
                                                                                return retval;
                                                                            }
                                                                            NoViableAltException nvae = new NoViableAltException("", 4, 27, input);

                                                                            throw nvae;

                                                                        }
                                                                    } else if ((LA4_26 == 52)) {
                                                                        alt4 = 2;
                                                                    } else {
                                                                        if (state.backtracking > 0) {
                                                                            state.failed = true;
                                                                            return retval;
                                                                        }
                                                                        NoViableAltException nvae = new NoViableAltException("", 4, 26, input);

                                                                        throw nvae;

                                                                    }
                                                                } else {
                                                                    if (state.backtracking > 0) {
                                                                        state.failed = true;
                                                                        return retval;
                                                                    }
                                                                    NoViableAltException nvae = new NoViableAltException("", 4, 25, input);

                                                                    throw nvae;

                                                                }
                                                            } else {
                                                                if (state.backtracking > 0) {
                                                                    state.failed = true;
                                                                    return retval;
                                                                }
                                                                NoViableAltException nvae = new NoViableAltException("", 4, 24, input);

                                                                throw nvae;

                                                            }
                                                        } else {
                                                            if (state.backtracking > 0) {
                                                                state.failed = true;
                                                                return retval;
                                                            }
                                                            NoViableAltException nvae = new NoViableAltException("", 4, 23, input);

                                                            throw nvae;

                                                        }
                                                    } else {
                                                        if (state.backtracking > 0) {
                                                            state.failed = true;
                                                            return retval;
                                                        }
                                                        NoViableAltException nvae = new NoViableAltException("", 4, 22, input);

                                                        throw nvae;

                                                    }
                                                } else {
                                                    if (state.backtracking > 0) {
                                                        state.failed = true;
                                                        return retval;
                                                    }
                                                    NoViableAltException nvae = new NoViableAltException("", 4, 21, input);

                                                    throw nvae;

                                                }
                                            } else {
                                                if (state.backtracking > 0) {
                                                    state.failed = true;
                                                    return retval;
                                                }
                                                NoViableAltException nvae = new NoViableAltException("", 4, 20, input);

                                                throw nvae;

                                            }
                                        } else {
                                            if (state.backtracking > 0) {
                                                state.failed = true;
                                                return retval;
                                            }
                                            NoViableAltException nvae = new NoViableAltException("", 4, 19, input);

                                            throw nvae;

                                        }
                                    } else {
                                        if (state.backtracking > 0) {
                                            state.failed = true;
                                            return retval;
                                        }
                                        NoViableAltException nvae = new NoViableAltException("", 4, 18, input);

                                        throw nvae;

                                    }
                                } else {
                                    if (state.backtracking > 0) {
                                        state.failed = true;
                                        return retval;
                                    }
                                    NoViableAltException nvae = new NoViableAltException("", 4, 17, input);

                                    throw nvae;

                                }
                            } else {
                                if (state.backtracking > 0) {
                                    state.failed = true;
                                    return retval;
                                }
                                NoViableAltException nvae = new NoViableAltException("", 4, 16, input);

                                throw nvae;

                            }
                        } else {
                            if (state.backtracking > 0) {
                                state.failed = true;
                                return retval;
                            }
                            NoViableAltException nvae = new NoViableAltException("", 4, 15, input);

                            throw nvae;

                        }
                    } else {
                        if (state.backtracking > 0) {
                            state.failed = true;
                            return retval;
                        }
                        NoViableAltException nvae = new NoViableAltException("", 4, 12, input);

                        throw nvae;

                    }
                } else {
                    if (state.backtracking > 0) {
                        state.failed = true;
                        return retval;
                    }
                    NoViableAltException nvae = new NoViableAltException("", 4, 1, input);

                    throw nvae;

                }
            }
                break;
            case ID: {
                int LA4_2 = input.LA(2);

                if ((LA4_2 == 49)) {
                    alt4 = 3;
                } else if ((LA4_2 == INT)) {
                    alt4 = 5;
                } else {
                    if (state.backtracking > 0) {
                        state.failed = true;
                        return retval;
                    }
                    NoViableAltException nvae = new NoViableAltException("", 4, 2, input);

                    throw nvae;

                }
            }
                break;
            case 60:
            case 65: {
                alt4 = 4;
            }
                break;
            case 58: {
                alt4 = 6;
            }
                break;
            case 54: {
                alt4 = 7;
            }
                break;
            case 67: {
                alt4 = 8;
            }
                break;
            case 63: {
                alt4 = 9;
            }
                break;
            case 66: {
                alt4 = 10;
            }
                break;
            case 62: {
                alt4 = 11;
            }
                break;
            case 61: {
                alt4 = 12;
            }
                break;
            case 59: {
                alt4 = 13;
            }
                break;
            default:
                if (state.backtracking > 0) {
                    state.failed = true;
                    return retval;
                }
                NoViableAltException nvae = new NoViableAltException("", 4, 0, input);

                throw nvae;

            }

            switch (alt4) {
            case 1:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_forDescriptStat_in_statement375);
                var_stmt = forDescriptStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, var_stmt.getTree());

            }
                break;
            case 2:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_forStat_in_statement381);
                forStat8 = forStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, forStat8.getTree());

            }
                break;
            case 3:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_funcStat_in_statement387);
                funcStat9 = funcStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, funcStat9.getTree());

            }
                break;
            case 4:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_condStat_in_statement393);
                condStat10 = condStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, condStat10.getTree());

            }
                break;
            case 5:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_define_in_statement399);
                define11 = define();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, define11.getTree());

            }
                break;
            case 6:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_bagStart_in_statement405);
                bagStart12 = bagStart();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, bagStart12.getTree());

            }
                break;
            case 7:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_bagEnd_in_statement411);
                bagEnd13 = bagEnd();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, bagEnd13.getTree());

            }
                break;
            case 8:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_whileStat_in_statement417);
                whileStat14 = whileStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, whileStat14.getTree());

            }
                break;
            case 9:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_breakStmt_in_statement423);
                breakStmt15 = breakStmt();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, breakStmt15.getTree());

            }
                break;
            case 10:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_rewindStmt_in_statement429);
                rewindStmt16 = rewindStmt();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, rewindStmt16.getTree());

            }
                break;
            case 11:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_nodeStart_in_statement435);
                nodeStart17 = nodeStart();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, nodeStart17.getTree());

            }
                break;
            case 12:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_nodeEnd_in_statement441);
                nodeEnd18 = nodeEnd();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, nodeEnd18.getTree());

            }
                break;
            case 13:

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_callSyntax_in_statement447);
                callSyntax19 = callSyntax();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, callSyntax19.getTree());

            }
                break;

            }
            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "statement"

    public static class callSyntax_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "callSyntax"

    // $var) ;
    public final BitStreamParser.callSyntax_return callSyntax() throws RecognitionException {
        BitStreamParser.callSyntax_return retval = new BitStreamParser.callSyntax_return();
        retval.start = input.LT(1);

        CommonTree             root_0                = null;

        Token                  var                   = null;
        Token                  string_literal20      = null;

        CommonTree             var_tree              = null;
        CommonTree             string_literal20_tree = null;
        RewriteRuleTokenStream stream_59             = new RewriteRuleTokenStream(adaptor, "token 59");
        RewriteRuleTokenStream stream_SYNTAX_NAME    = new RewriteRuleTokenStream(adaptor, "token SYNTAX_NAME");

        try {

            // )

            {
                string_literal20 = (Token) match(input, 59, FOLLOW_59_in_callSyntax465);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_59.add(string_literal20);

                var = (Token) match(input, SYNTAX_NAME, FOLLOW_SYNTAX_NAME_in_callSyntax469);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_SYNTAX_NAME.add(var);

                // AST REWRITE
                // elements: var
                // token labels: var
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleTokenStream   stream_var    = new RewriteRuleTokenStream(adaptor, "token var", var);
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 107:3: -> ^( KEY_CALL $var)
                    {

                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_CALL, "KEY_CALL"), root_1);

                            adaptor.addChild(root_1, stream_var.nextNode());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "callSyntax"

    public static class whileStat_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "whileStat"

    // ^( KEY_WHILE KEY_LB logical_expression KEY_RB block ) ;
    public final BitStreamParser.whileStat_return whileStat() throws RecognitionException {
        BitStreamParser.whileStat_return retval = new BitStreamParser.whileStat_return();
        retval.start = input.LT(1);

        CommonTree                                root_0                    = null;

        Token                                     string_literal21          = null;
        Token                                     char_literal22            = null;
        Token                                     char_literal24            = null;
        BitStreamParser.logical_expression_return logical_expression23      = null;

        BitStreamParser.block_return              block25                   = null;

        CommonTree                                string_literal21_tree     = null;
        CommonTree                                char_literal22_tree       = null;
        CommonTree                                char_literal24_tree       = null;
        RewriteRuleTokenStream                    stream_67                 = new RewriteRuleTokenStream(adaptor, "token 67");
        RewriteRuleTokenStream                    stream_48                 = new RewriteRuleTokenStream(adaptor, "token 48");
        RewriteRuleTokenStream                    stream_50                 = new RewriteRuleTokenStream(adaptor, "token 50");
        RewriteRuleSubtreeStream                  stream_logical_expression = new RewriteRuleSubtreeStream(adaptor, "rule logical_expression");
        RewriteRuleSubtreeStream                  stream_block              = new RewriteRuleSubtreeStream(adaptor, "rule block");
        try {

            // KEY_WHILE KEY_LB logical_expression KEY_RB block ) )

            {
                string_literal21 = (Token) match(input, 67, FOLLOW_67_in_whileStat502);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_67.add(string_literal21);

                char_literal22 = (Token) match(input, 48, FOLLOW_48_in_whileStat504);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_48.add(char_literal22);

                pushFollow(FOLLOW_logical_expression_in_whileStat506);
                logical_expression23 = logical_expression();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_logical_expression.add(logical_expression23.getTree());

                char_literal24 = (Token) match(input, 50, FOLLOW_50_in_whileStat508);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_50.add(char_literal24);

                pushFollow(FOLLOW_block_in_whileStat510);
                block25 = block();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_block.add(block25.getTree());

                // AST REWRITE
                // elements: block, logical_expression
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 114:3: -> ^( KEY_WHILE KEY_LB logical_expression KEY_RB block )
                    {

                        // logical_expression KEY_RB block )
                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_WHILE, "KEY_WHILE"), root_1);

                            adaptor.addChild(root_1, (CommonTree) adaptor.create(KEY_LB, "KEY_LB"));

                            adaptor.addChild(root_1, stream_logical_expression.nextTree());

                            adaptor.addChild(root_1, (CommonTree) adaptor.create(KEY_RB, "KEY_RB"));

                            adaptor.addChild(root_1, stream_block.nextTree());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "whileStat"

    public static class condStat_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "condStat"

    public final BitStreamParser.condStat_return condStat() throws RecognitionException {
        BitStreamParser.condStat_return retval = new BitStreamParser.condStat_return();
        retval.start = input.LT(1);

        CommonTree                        root_0       = null;

        BitStreamParser.ifStat_return     ifStat26     = null;

        BitStreamParser.elseifStat_return elseifStat27 = null;

        BitStreamParser.elseStat_return   elseStat28   = null;

        try {

            {
                root_0 = (CommonTree) adaptor.nil();

                pushFollow(FOLLOW_ifStat_in_condStat543);
                ifStat26 = ifStat();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    adaptor.addChild(root_0, ifStat26.getTree());

                loop5: do {
                    int alt5  = 2;
                    int LA5_0 = input.LA(1);

                    if ((LA5_0 == 64)) {
                        int LA5_1 = input.LA(2);

                        if ((LA5_1 == 65)) {
                            alt5 = 1;
                        }

                    }

                    switch (alt5) {
                    case 1:

                    {
                        pushFollow(FOLLOW_elseifStat_in_condStat545);
                        elseifStat27 = elseifStat();

                        state._fsp--;
                        if (state.failed)
                            return retval;
                        if (state.backtracking == 0)
                            adaptor.addChild(root_0, elseifStat27.getTree());

                    }
                        break;

                    default:
                        break loop5;
                    }
                } while (true);

                loop6: do {
                    int alt6  = 2;
                    int LA6_0 = input.LA(1);

                    if ((LA6_0 == 64)) {
                        alt6 = 1;
                    }

                    switch (alt6) {
                    case 1:

                    {
                        pushFollow(FOLLOW_elseStat_in_condStat548);
                        elseStat28 = elseStat();

                        state._fsp--;
                        if (state.failed)
                            return retval;
                        if (state.backtracking == 0)
                            adaptor.addChild(root_0, elseStat28.getTree());

                    }
                        break;

                    default:
                        break loop6;
                    }
                } while (true);

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "condStat"

    public static class ifStat_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "ifStat"

    // block -> ^( KEY_IF KEY_LB logical_expression KEY_RB block ) ;
    public final BitStreamParser.ifStat_return ifStat() throws RecognitionException {
        BitStreamParser.ifStat_return retval = new BitStreamParser.ifStat_return();
        retval.start = input.LT(1);

        CommonTree                                root_0                    = null;

        Token                                     string_literal29          = null;
        Token                                     string_literal30          = null;
        Token                                     char_literal31            = null;
        Token                                     char_literal33            = null;
        BitStreamParser.logical_expression_return logical_expression32      = null;

        BitStreamParser.block_return              block34                   = null;

        CommonTree                                string_literal29_tree     = null;
        CommonTree                                string_literal30_tree     = null;
        CommonTree                                char_literal31_tree       = null;
        CommonTree                                char_literal33_tree       = null;
        RewriteRuleTokenStream                    stream_48                 = new RewriteRuleTokenStream(adaptor, "token 48");
        RewriteRuleTokenStream                    stream_65                 = new RewriteRuleTokenStream(adaptor, "token 65");
        RewriteRuleTokenStream                    stream_60                 = new RewriteRuleTokenStream(adaptor, "token 60");
        RewriteRuleTokenStream                    stream_50                 = new RewriteRuleTokenStream(adaptor, "token 50");
        RewriteRuleSubtreeStream                  stream_logical_expression = new RewriteRuleSubtreeStream(adaptor, "rule logical_expression");
        RewriteRuleSubtreeStream                  stream_block              = new RewriteRuleSubtreeStream(adaptor, "rule block");
        try {

            // block -> ^( KEY_IF KEY_LB logical_expression KEY_RB block ) )

            {

                int alt7  = 2;
                int LA7_0 = input.LA(1);

                if ((LA7_0 == 65)) {
                    alt7 = 1;
                } else if ((LA7_0 == 60)) {
                    alt7 = 2;
                } else {
                    if (state.backtracking > 0) {
                        state.failed = true;
                        return retval;
                    }
                    NoViableAltException nvae = new NoViableAltException("", 7, 0, input);

                    throw nvae;

                }
                switch (alt7) {
                case 1:

                {
                    string_literal29 = (Token) match(input, 65, FOLLOW_65_in_ifStat570);
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_65.add(string_literal29);

                }
                    break;
                case 2:

                {
                    string_literal30 = (Token) match(input, 60, FOLLOW_60_in_ifStat578);
                    if (state.failed)
                        return retval;
                    if (state.backtracking == 0)
                        stream_60.add(string_literal30);

                }
                    break;

                }

                char_literal31 = (Token) match(input, 48, FOLLOW_48_in_ifStat586);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_48.add(char_literal31);

                pushFollow(FOLLOW_logical_expression_in_ifStat588);
                logical_expression32 = logical_expression();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_logical_expression.add(logical_expression32.getTree());

                char_literal33 = (Token) match(input, 50, FOLLOW_50_in_ifStat590);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_50.add(char_literal33);

                pushFollow(FOLLOW_block_in_ifStat592);
                block34 = block();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_block.add(block34.getTree());

                // AST REWRITE
                // elements: logical_expression, block
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 130:5: -> ^( KEY_IF KEY_LB logical_expression KEY_RB block )
                    {

                        // KEY_RB block )
                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_IF, "KEY_IF"), root_1);

                            adaptor.addChild(root_1, (CommonTree) adaptor.create(KEY_LB, "KEY_LB"));

                            adaptor.addChild(root_1, stream_logical_expression.nextTree());

                            adaptor.addChild(root_1, (CommonTree) adaptor.create(KEY_RB, "KEY_RB"));

                            adaptor.addChild(root_1, stream_block.nextTree());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "ifStat"

    public static class elseStat_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "elseStat"

    public final BitStreamParser.elseStat_return elseStat() throws RecognitionException {
        BitStreamParser.elseStat_return retval = new BitStreamParser.elseStat_return();
        retval.start = input.LT(1);

        CommonTree                   root_0                = null;

        Token                        string_literal35      = null;
        BitStreamParser.block_return block36               = null;

        CommonTree                   string_literal35_tree = null;
        RewriteRuleTokenStream       stream_64             = new RewriteRuleTokenStream(adaptor, "token 64");
        RewriteRuleSubtreeStream     stream_block          = new RewriteRuleSubtreeStream(adaptor, "rule block");
        try {

            {
                string_literal35 = (Token) match(input, 64, FOLLOW_64_in_elseStat631);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_64.add(string_literal35);

                pushFollow(FOLLOW_block_in_elseStat633);
                block36 = block();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_block.add(block36.getTree());

                // AST REWRITE
                // elements: block
                // token labels:
                // rule labels: retval
                // token list labels:
                // rule list labels:
                // wildcard labels:
                if (state.backtracking == 0) {

                    retval.tree = root_0;
                    RewriteRuleSubtreeStream stream_retval = new RewriteRuleSubtreeStream(adaptor, "rule retval",
                            retval != null ? retval.tree : null);

                    root_0 = (CommonTree) adaptor.nil();
                    // 137:5: -> ^( KEY_ELSE block )
                    {

                        {
                            CommonTree root_1 = (CommonTree) adaptor.nil();
                            root_1 = (CommonTree) adaptor.becomeRoot((CommonTree) adaptor.create(KEY_ELSE, "KEY_ELSE"), root_1);

                            adaptor.addChild(root_1, stream_block.nextTree());

                            adaptor.addChild(root_0, root_1);
                        }

                    }

                    retval.tree = root_0;
                }

            }

            retval.stop = input.LT(-1);

            if (state.backtracking == 0) {

                retval.tree = (CommonTree) adaptor.rulePostProcessing(root_0);
                adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
            }
        } catch (RecognitionException re) {
            reportError(re);
            recover(input, re);
            retval.tree = (CommonTree) adaptor.errorNode(input, retval.start, input.LT(-1), re);

        }

        finally {
            // do for sure before leaving
        }
        return retval;
    }
    // $ANTLR end "elseStat"

    public static class elseifStat_return extends ParserRuleReturnScope {
        CommonTree tree;

        public Object getTree() {
            return tree;
        }
    };

    // $ANTLR start "elseifStat"

    // block -> ^( KEY_ELSEIF KEY_LB logical_expression KEY_RB block ) ;
    public final BitStreamParser.elseifStat_return elseifStat() throws RecognitionException {
        BitStreamParser.elseifStat_return retval = new BitStreamParser.elseifStat_return();
        retval.start = input.LT(1);

        CommonTree                                root_0                    = null;

        Token                                     string_literal37          = null;
        Token                                     string_literal38          = null;
        Token                                     char_literal39            = null;
        Token                                     char_literal41            = null;
        BitStreamParser.logical_expression_return logical_expression40      = null;

        BitStreamParser.block_return              block42                   = null;

        CommonTree                                string_literal37_tree     = null;
        CommonTree                                string_literal38_tree     = null;
        CommonTree                                char_literal39_tree       = null;
        CommonTree                                char_literal41_tree       = null;
        RewriteRuleTokenStream                    stream_48                 = new RewriteRuleTokenStream(adaptor, "token 48");
        RewriteRuleTokenStream                    stream_64                 = new RewriteRuleTokenStream(adaptor, "token 64");
        RewriteRuleTokenStream                    stream_65                 = new RewriteRuleTokenStream(adaptor, "token 65");
        RewriteRuleTokenStream                    stream_50                 = new RewriteRuleTokenStream(adaptor, "token 50");
        RewriteRuleSubtreeStream                  stream_logical_expression = new RewriteRuleSubtreeStream(adaptor, "rule logical_expression");
        RewriteRuleSubtreeStream                  stream_block              = new RewriteRuleSubtreeStream(adaptor, "rule block");
        try {

            // -> ^( KEY_ELSEIF KEY_LB logical_expression KEY_RB block ) )

            {
                string_literal37 = (Token) match(input, 64, FOLLOW_64_in_elseifStat666);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_64.add(string_literal37);

                string_literal38 = (Token) match(input, 65, FOLLOW_65_in_elseifStat668);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_65.add(string_literal38);

                char_literal39 = (Token) match(input, 48, FOLLOW_48_in_elseifStat670);
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_48.add(char_literal39);

                pushFollow(FOLLOW_logical_expression_in_elseifStat672);
                logical_expression40 = logical_expression();

                state._fsp--;
                if (state.failed)
                    return retval;
                if (state.backtracking == 0)
                    stream_logical_expression.add(logical_expression40.getTree());

